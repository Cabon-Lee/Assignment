# Assignment
Assignment for Rookie

1. 현재 구현되어 있는 사항
- 매크로를 이용한 리플렉션 시스템
- 리플렉션 시스템을 활용한 가비지 컬렉션
- 클래스 및 멤버 변수 리플리케이션
- void(void) 함수의 RPC

2. 시뮬레이션 시나리오 정리
1) 개요 : 
싱글 스레드에서 서버와 클라이언트의 사이의 통신을 시뮬레이션하기 위해,
각 차례마다 서버와 클라이언트는 각자 패킷으로 통신을 주고 받습니다.
ex) 클라이언트에서 리플리케이션 가능한 클래스를 생성할 경우,
해당 클래스의 정보를 패킷화 하여 서버가 사용하는 queue에 push합니다.
서버는 자신의 차례에 queue를 확인하고 처리합니다.

게임을 모방하는 것이 가장 직관적일 것 같아, 간단하게 시뮬레이션 했습니다.
서버에서 클라이언트에게 몬스터 생성 RPC를 호출하고,
클라이언트에서는 총을 발사할지 말지 결정하여 생성된 몬스터를 처리합니다.

2) 프로그램 흐름
[클라이언트]
- 게임 로직이 클라이언트에 올라갑니다.
- 게임 로직에서 월드와 주인공을 생성하고, 서버에 클래스 리플리케이션을 요청합니다.

[서버]
- 서버가 리플리케이션 패킷을 받아 서버에 World와 Hero를 생성합니다.
- 서버에서 클라이언트에 MonsterSummon RPC를 호출합니다. (선택 사항)
- Tick()을 통해 전체 업데이트를 합니다.
- 리플리케이션된 변수 중에 변한 것이 있다면, 내용을 패킷화하여 전달합니다.
- 가비지 컬렉션합니다.

[클라이언트]
- 서버에서 넘어온 패킷에 따라 리플리케이션 혹은 RPC를 처리합니다.
- 총알을 발사할지 말지 결정합니다. (선택 사항)
- Tick()을 통해 전체 업데이트를 합니다.
- 몬스터가 죽었다면, Destory RPC를 호출합니다.
- 리플리케이션된 변수 중에 변한 것이 있다면, 내용을 패킷화하여 전달합니다.
- 가비지 컬렉션합니다.

3. 상세 정보
1) 리플렉션
- int, float, std::stirng, std::list를 리플렉션 했습니다.
- 원하는 멤버 변수를 리플렉션 매크로로 처리하면 콘솔에서 확인할 수 있습니다.
- std::list<>를 통해 현재 담겨있는 어떤 오브젝트들이 담겨있는지 확인할 수 있습니다.
- 상속받은 클래스도 리플렉션할 수 있습니다.

2) 가비지 컬렉션
- 자신의 클래스 형태에 따라 멤버 변수에 접근하여 해당 멤버 변수가 Object를 상속 받은 경우,
재귀 형태로 마크되게 됩니다.
- root를 오브젝트들 통해 mark가 진행됩니다.
- root 오브젝트의 list에 포함되어 있는 경우, mark 됩니다.
- root 오브젝트와 연관이 없는 클래스는 mark되지 않습니다.
ex) root set되지 않고 단순히 new한 클래스의 경우(Objcet를 상속 받은 클래스)
- list에 있는 Destroy될 오브젝트는 먼저 list에서 삭제됩니다.

3) 리플리케이션
- int, float, std::string에 대해 리플리케이션했습니다.
- 리플리케이션할 멤버변수를 매크로 처리하면, 해당 클래스도 리플리케이션 대상이 됩니다.
ex) 리플리케이션 대상 멤버 변수인 currHp를 가지고 있는,
Monster 클래스를 생성하면 서버 혹은 클라이언트에 리플리케이션됩니다.
- 이전 데이터를 기록하고 보관하다가, Tick()의 마지막에서 리플리케이션된 멤버 변수를 조사합니다.
- 바뀐 데이터를 발견하게 되면 리플리케이션합니다.

4) RPC
- void(void) 형태의 멤버 변수를 리플리케이션합니다.
- 서버 혹은 클라이언트에서 생성된 클래스의 id와 멤버 함수의 이름을 가지고
리플리케이션된 클래스에게 원하는 함수를 호출하도록 합니다.
